---
title: "Getting Started"
---

**Workflows** is a Durable Execution Engine that is composed of **Qstash** Server and the SDK.

- It allows to break **free of time limitations** of serverless platforms.
- It enables **recovery from partial failures**, with the ability to continue a workflow run from an intermediate step.
- It is designed to seamlessly integrate with **your existing infrastructure**. The application code will not be uploaded to QStash.
- It provides **all the power of QStash** while abstracting away the complexities, allowing you to focus on implementing the **essential parts**.

Here is an example how an an endpoint might use our SDK:

```javascript 
import { serve } from "@upstash/qstash/nextjs";
import { sendEmail, UserQuestionRequest } from "./utils"

export const POST = serve<{userRequest: UserQuestionRequest}>(async context => {
    await context.run("saveUser", async() => {
        await saveUser(userRequest)
    })
    
    await context.sleep("sleepDays" , 3d)

    await response = context.call("call open ai", "https://qstash.upstash.io/llm/v1/chat/completions", "POST", 
      {"model": "gpt-3.5-turbo-instruct", "prompt": request.question},
      {"Authorization": `Bearer $OPENAI_API_KEY`,  "Content-Type": "application/json"}
    );

    await context.run("sendEmail", async() => {
        await sendEmail(userRequest, response)
    })
  }
)
```

This example is for Next.js, to check all other plaforms and usage examples see [Supported Platforms](/qstash/workflows/platforms/platforms)

You can also check our [All In One Example](/qstash/workflows/examples/allInOne) for more complex scenarios. 

You will call the endpoint as your usual endpoint. The call will not execute all the code but it will just trigger it. 

```bash 
curl -XPOST https://cool-app.vercel.app/ask -d '{"userId": 42, "question" : "what is the meaning of life?" }'
```

And in return it will return a `workflowRunId`. 

```json
{"workflowRunId":"wfr_TzazoUCuZmFGp2u9cdy5K"}
```

This run id can be used to see [the logs](/qstash/workflows/howto/monitor) of the workflow run in the console, 
and also it can be used to [cancel](/qstash/workflows/howto/cancel) the workflow run.

To get into more detail see our api desription here:
- [context.run](/qstash/workflows/basics/api#context-run)
- [context.sleep](/qstash/workflows/basics/api#context-sleep)
- [context.sleepUntil](/qstash/workflows/basics/api#context-sleepuntil)
- [context.call](/qstash/workflows/basics/api#context-call)

See [caveats](/qstash/workflows/basics/caveats) for more complex usages of the API and things to 
be careful when using it.

And see following documentations about how to:
- [cancel](/qstash/workflows/howto/cancel) a running workflow
- monitor and handle [failed](/qstash/workflows/howto/failures) of a workflow run
- [monitor](/qstash/workflows/howto/failures) all finished and in progress runs
- [schedule](/qstash/workflows/howto/schedule) a workflow endpoint with cron definition
- [secure](/qstash/workflows/howto/security) calls to a workflow endpoint
- handle [workflow route code changes](/qstash/workflows/howto/changes) 
- test your workflow app [locally on development phase](/qstash/workflows/howto/local-development)

If you are curious, you can checkout how we make sure each step is run seperatly and 
how do we get away with platform specific timeouts [here](/qstash/workflows/how)

And lastly you can checkout our [roadmap](/qstash/workflows/roadmap) to see what is planned for the future.
