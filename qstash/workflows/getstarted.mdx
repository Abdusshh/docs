---
title: "Getting Started"
---

**Workflows** is an SDK designed to seamlessly integrate with your existing infrastructure, especially to overcome serverless platform limitations. Built on top of **Qstash**, it provides all the power of Qstash while abstracting away the complexities, allowing you to focus on implementing the **essential parts**.

Here's how you can get started with our SDK and utilize its features, explained through inline comments.

```javascript 
import { serve } from "@upstash/qstash/workflow/nextjs";
import { sendEmail, reportFailure, getUserEmail, UserQuestionRequest } from "./utils"

// THE WORKFLOW IS SERVED AS USUAL ENDPOINT //
// YOU WILL CALL YOUR ENDPOINT AS USUAL     //
export const POST = serve<{userRequest: UserQuestionRequest}>({async context => {
    // ENTIRE RUN CAN TAKE LONGER THAN THE PLATFORM TIMEOUT //
    const request = context.requestPayload.userRequest

    // EVERY STEP IS AUTOMATICALLY RETRIED IN CASE IT FAILS //
    const emailPromise = context.run("retrieveEmail", async () => {
        return await getUserEmail(request.userId)
    });

    // EXTERNAL CALLS CAN TAKE UP TO HOURS WITHOUT CAUSING A PROBLEM //
    const openAIPromise = context.call(
      "call open ai",
      "https://api.openai.com/v1/chat/completions",
      "POST",  "Authorization: Bearer $OPENAI_API_KEY",
      {"model": "gpt-3.5-turbo-16k",
        "messages": [{"role": "system", "content": "You are a helpful assistant." },
                     {"role": "user","content": request.question}]}
    )

    // WAIT FOR PARALEL UNRELATED THINGS TOGETHER //
    email, response = await Promise.all(emailPromise, openAiPromise)

    // IF YOUR ENDPOINT GOES DOWN ANY MOMENT, EVERYTHING IS SAFE //
    // THE ENDPOINT WILL CONTINUE TO WORK WHERE IT LEFT OFF.     //
    for (let i = 0; i < 3; i++) {
        // USE FOR LOOPS/IF STATEMENTS AS YOU ARE USED TO IT 
        emailSendSuccess = await context.run("sendEmail", async() => {
            const success = await sendEmail(email, response)
            retrun success
        })
        if emailSendSuccess {
            return 
        }

        // POSTPONE A RUN UP TO YEARS/UNTIL A DATE WITHOUT WORRYING PLATFORM LIMITS
        await context.sleep("sleep for email retry" , 1d)
    }

    await context.run("report a failure to internal system", async() => {
        await reportFailure(request.userId)
    })
  }
})
```
