---
title: "Getting Started"
---

**Workflows** is an SDK designed to seamlessly integrate with your existing infrastructure, especially to overcome serverless platform limitations. Built on top of **QStash**, it provides all the power of QStash while abstracting away the complexities, allowing you to focus on implementing the **essential parts**.

Here's how you can get started with our SDK and utilize its features, explained through inline comments.

```javascript 
import { serve } from "@upstash/qstash/workflow/nextjs";
import { sendEmail, reportFailure, getUserEmail, UserQuestionRequest } from "./utils"

// THE WORKFLOW IS SERVED AS USUAL ENDPOINT //
// YOU WILL CALL YOUR ENDPOINT AS USUAL     //
export const POST = serve<{userRequest: UserQuestionRequest}>({async context => {
    // ENTIRE RUN CAN TAKE LONGER THAN THE PLATFORM TIMEOUT //
    const request = context.requestPayload.userRequest

    // EVERY STEP IS AUTOMATICALLY RETRIED IN CASE IT FAILS //
    const emailPromise = context.run("retrieveEmail", async () => {
        return await getUserEmail(request.userId)
    });

    // EXTERNAL CALLS CAN TAKE UP TO HOURS WITHOUT CAUSING A PROBLEM //
    const openAIPromise = context.call(
      "call open ai",
      "https://api.openai.com/v1/chat/completions",
      "POST",  "Authorization: Bearer $OPENAI_API_KEY",
      {"model": "gpt-3.5-turbo-16k",
        "messages": [{"role": "system", "content": "You are a helpful assistant." },
                     {"role": "user","content": request.question}]}
    )

    // WAIT FOR PARALEL UNRELATED THINGS TOGETHER //
    email, response = await Promise.all(emailPromise, openAiPromise)

    // IF YOUR ENDPOINT GOES DOWN ANY MOMENT, EVERYTHING IS SAFE //
    // THE ENDPOINT WILL CONTINUE TO WORK WHERE IT LEFT OFF.     //
    for (let i = 0; i < 3; i++) {
        // USE FOR LOOPS/IF STATEMENTS AS YOU ARE USED TO IT 
        emailSendSuccess = await context.run("sendEmail", async() => {
            const success = await sendEmail(email, response)
            return success
        })
        if emailSendSuccess {
            return 
        }

        // POSTPONE A RUN UP TO YEARS/UNTIL A DATE WITHOUT WORRYING PLATFORM LIMITS
        await context.sleep("sleep for email retry" , 1d)
    }

    await context.run("report a failure to internal system", async() => {
        await reportFailure(request.userId)
    })
  }
})
```

This example is nextjs, to see all other plaforms and usage examples see [Supported Platforms](/qstash/workflows/platforms/platforms)

You will call the endpoint as your usual endpoint. The call will not execute all the code but it will just trigger it. 

```bash 
curl -X POST -d signin-app.vercel.app/sign -d '{"userId": 42, "question" : "what is the meaning of life?" }'
```

And in return it will return a `workflowRunId`. 

```json
{"workflowRunId":"wfr_TzazoUCuZmFGp2u9cdy5K"}
```

This run id can be used to see [the logs](/qstash/workflows/howto/monitor) of the workflow run in the console, 
and also it can be used to [cancel](/qstash/workflows/howto/cancel) the workflow run.

To get into more detail see our api desription here:
- [context.run](/qstash/workflows/basics/api#context-run)
- [context.sleep](/qstash/workflows/basics/api#context-sleep)
- [context.sleepUntil](/qstash/workflows/basics/api#context-sleepuntil)
- [context.call](/qstash/workflows/basics/api#context-call)

See [caveats](/qstash/workflows/basics/caveats) for more complex usages of the API and things to 
be careful when using it.

And see following documentations about how to:
- [cancel](/qstash/workflows/howto/cancel) a running workflow
- monitor and handle [failed](/qstash/workflows/howto/failures) of a workflow run
- [monitor](/qstash/workflows/howto/failures) all finished and in progress runs
- [schedule](/qstash/workflows/howto/schedule) a workflow endpoint with cron definition
- [secure](/qstash/workflows/howto/security) calls to a workflow endpoint
- handle [workflow route code changes](/qstash/workflows/howto/changes) 

If you are curious, you can checkout how we make sure each step is run seperatly and 
how do we get away with platform specific timeouts [here](/qstash/workflows/how)

And lastly you can checkout our [roadmap](/qstash/workflows/roadmap) to see what is planned for the future.

TODO links to examples?