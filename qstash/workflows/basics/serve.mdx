---
title: "Serve Method"
---

The `serve` method is central to creating workflow endpoints. It enables you to define an endpoint that serves a workflow.

In this guide, we focus on the options available in the `serve` method.

Hereâ€™s how it looks in a Next.js application:

```javascript
import { serve } from "@upstash/qstash/nextjs";

export const POST = serve<string>(
  async (context) => {
    const input = context.requestPayload;
    const result1 = await context.run("step1", async () => {
      return someWork(input);
    });

    await context.run("step2", async () => {
      someOtherWork(result1);
    });
  }
);
```

The `serve` method takes an async function, known as a "Route Function," which accepts a `WorkflowContext` object. See [the context](/qstash/workflows/basics/context). documentation for more details.

The Route Function is the core of your workflow, where you define the steps and logic.

## Platform Support

Currently, the `serve` method is implemented across several platforms. See [the platforms](/qstash/workflows/platforms/platforms) page for more details.

## Serve Options

In addition to the Route Function, the `serve` method offers several options to configure its behavior:

```javascript
import { Client } from "@upstash/qstash";
import { serve } from "@upstash/qstash/nextjs";

export const POST = serve<string>(
  async (context) => {
    ...
  },
  // options:
  {
    qstashClient: new Client({ token: process.env.QSTASH_TOKEN })
    ...
  }
);
```

### `qstashClient`

The `qstashClient` option allows you to pass a QStash Client explicitly.

By default, a `qstashClient` is initialized as:

```javascript
new Client({
  baseUrl: process.env.QSTASH_URL!,
  token: process.env.QSTASH_TOKEN!,
})
```

If you already have a QStash client initialized or are using different environment variables for the URL or token, you can pass your own client explicitly.

```javascript
export const POST = serve<string>(
  async (context) => {
    ...
  },
  // options:
  {
    qstashClient: new Client({ token: process.env.QSTASH_TOKEN })
  }
);
```

### `receiver`

You can pass a QStash Receiver to verify that **every** request received by the endpoint is coming from QStash.

```javascript
import { Receiver } from "@upstash/qstash";
import { serve } from "@upstash/qstash/nextjs";

export const POST = serve<string>(
  async (context) => {
    ...
  },
  // options:
  {
    receiver: new Receiver({
      currentSigningKey: process.env.QSTASH_CURRENT_SIGNING_KEY!,
      nextSigningKey: process.env.QSTASH_NEXT_SIGNING_KEY!,
    })
  }
);
```

By default, a receiver is initialized if the `QSTASH_CURRENT_SIGNING_KEY` and `QSTASH_NEXT_SIGNING_KEY` environment variables are set. If you want to disable the receiver, either remove these environment variables or pass `receiver: undefined` in the options.

### `failureUrl`

The `failureUrl` option allows you to specify a URL that QStash will call if a workflow run exhausts all its [retries](/qstash/features/retry) and fails.

```javascript
export const POST = serve<string>(
  async (context) => {
    ...
  },
  // options:
  {
    failureUrl: "https://www.failure-handling-endpoint.com/api"
  }
);
```

The specified `failureUrl` will be called with [the failure callback payload](qstash/features/callbacks#what-is-a-failure-callback), and the error message will be included in the `body` field.

The default value is `undefined`, meaning no URL is called in case of failure.

### `failureFunction`

The `failureFunction` option allows you to define a function to be executed when your workflow exhausts all its [retries](/qstash/features/retry) and fails.

```javascript
export const POST = serve<string>(
  async (context) => {
    ...
  },
  // options:
  {
    failureFunction: async (
      context,      // context during failure
      failStatus,   // failure status
      failResponse, // failure message
      failHeaders   // failure headers
    ) => {
      // handle the failure
    }
  }
);
```

If both `failureUrl` and `failureFunction` are provided, the value of `failureUrl` will be ignored.

Note that if you are using a [Custom Authorization Method](/qstash/workflows/howto/security#custom-authorization-method), you should add authentication to `failureFunction` as well.

By default, `failureFunction` is `undefined`, meaning no action is taken on failure.

### `verbose`

To gain insights into how the workflow operates, you can enable verbose mode:

```javascript
export const POST = serve<string>(
  async (context) => {
    ...
  },
  // options:
  {
    verbose: true
  }
);
```

Each log entry has the following structure:

```
{
  timestamp: number,
  workflowRunId: string,
  logLevel: string,
  eventType: string,
  details: unknown,
}
```

The `eventType` can be:
- `ENDPOINT_START` each time the endpoint is called
- `RUN_SINGLE` or `RUN_PARALLEL` when step(s) are executed
- `SUBMIT_STEP` when a single step is executed
- `SUBMIT_FIRST_INVOCATION` when a new workflow run starts
- `SUBMIT_CLEANUP` when a workflow run finishes
- `SUBMIT_THIRD_PARTY_RESULT` when a third-party call result is received (see `context.call`)

Verbose mode is disabled by default.

### `initialPayloadParser`

When calling the workflow endpoint to start a workflow run, the payload of your request is expected to be empty, a string, or JSON by default.

If your payload is of a different type, you can use the `initialPayloadParser` option to process it as needed.

You can also define the payload type through `serve`:

```javascript
type MyPayload = {
  foo: string,
  bar: number
}

// Set the type of the initial payload to MyPayload:
export const POST = serve<MyPayload>(
  async (context) => {
    // The result of initialPayloadParser is available in the `requestPayload` field:
    const payload: MyPayload = context.requestPayload; 
  },
  // options:
  {
    // A parser that converts a string to MyPayload
    initialPayloadParser: (initialPayload) => {
      const myPayload: MyPayload = getMyPayload(initialPayload);
      return myPayload;
    }
  }
);
```

### `url`

Since a workflow run involves multiple calls to the workflow endpoint, the `serve` method needs to know where the endpoint is hosted.

Typically, this is determined by checking the `request.url` field.

However, if you are using a proxy or a local tunnel for development, you may want to override the URL inferred from `request.url`.

This can be done using the `url` option, which specifies where the workflow endpoint can be accessed by QStash:

```javascript
export const POST = serve<string>(
  async (context) => {
    ...
  },
  // options:
  {
    url: "https://www.workflow-endpoint.com/api/workflow"
  }
);
```

By default, `url` is `undefined`, and the URL is inferred from `request.url`.

### `baseUrl`

An alternative to the `url` option is the `baseUrl` option. While `url` replaces the entire URL inferred from `request.url`, `baseUrl` only changes the base of the URL:

```javascript
export const POST = serve<string>(
  async (context) => {
    ...
  },
  // options:
  {
    baseUrl: "https://www.workflow-endpoint.com"
  }
);
```

The default value of `baseUrl` is `undefined`.

If you want to apply `baseUrl` across your entire application, you can set the `UPSTASH_WORKFLOW_URL` environment variable.

A use case is the local development. See [local development](/qstash/workflows/howto/local-development) for more details.

