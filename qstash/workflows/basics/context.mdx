---
title: "Workflow Context"
---

In the [`serve` method](https://upstash-workflows.mintlify.app/qstash/workflows/basics/serve), you define a 'Route Function' where steps of the workflow are defined.

The steps are defined through the `WorkflowContext` object. In addition to defining steps, context allows you to access information such as initial request payload & headers or the current workflow run id.

```javascript
import { serve } from "@upstash/qstash/nextjs";

export const POST = serve<string>(
  // route function receives a WorkflowContext as parameter:
  async (context) => {
    const input = context.requestPayload;
    const result1 = await context.run("step1", async () => {
      return someWork(input);
    });
    
    ...
  }
);
```

On this page, we document the fields and methods of the `WorkflowContext`.

## Fields

### `qstashClient`

`context.qstashClient` allows you to access a QStash client which is also the client used by the `serve` method.

Can be overwritten by passing [`qstashClient` parameter in `serve`](/qstash/workflows/basics/serve#qstashclient-option):

```javascript
export const POST = serve(
  async (context) => {
    const qstashClient = context.qstashClient
  }
)
```

### `workflowRunId`

Run id of the current workflow

### `url`

URL where the workflow endpoint is hosted, like `https://www.my-backend.com/api/workflow`.

Can be overwritten with [`url` parameter](/qstash/workflows/basics/serve#url-option) or updated with [`baseUrl` parameter](/qstash/workflows/basics/serve#failureurl-option):

```javascript
export const POST = serve(
  async (context) => {
    const url = context.url
  }
)
```

### `failureUrl`

URL to be called in case of workflow failure.

```javascript
export const POST = serve(
  async (context) => {
    const failureUrl = context.failureUrl
  }
)
```

Can be configured through [`failureUrl`](/qstash/workflows/basics/serve#failureurl-option) or [`failureFunction`](/qstash/workflows/basics/serve#failurefunction-option) parameters

### `requestPayload`

Payload received in the request which started the workflow run.

Its type can be set through `serve`.

```javascript
type MyPayload = {
  foo: string,
  bar: number
}

export const POST = serve<MyPayload>(
  async (context) => {
    const payload = context.requestPayload
  }
)
```

### `rawInitialPayload`

Payload received in the request which started the workflow run as a **string**.

```javascript
export const POST = serve<MyPayload>(
  async (context) => {
    const payload = context.rawInitialPayload
  }
)
```

### `headers`

Headers received in the request which started the workflow run as a `Headers` object.

```javascript
export const POST = serve<MyPayload>(
  async (context) => {
    const headers = context.headers
  }
)
```

## Methods

Each context method allows you to define a workflow step. Each should be awaited.

### `context.run` Method

`context.run` requires a step name and the code of the step as an async function. Each step can run for the full duration allowed by the platform. The result of each step is stored and remembered by QStash, allowing it to continue from where it left off in case of failure (e.g., endpoint downtime).

Here are a couple of examples to demonstrate its usage:

<CodeGroup>
```javascript serial
export const POST = serve<string>(
  async (context) => {
    const input = context.requestPayload;
    const result1 = await context.run("step1", async () => {
      return someWork(input);
    });

    await context.run("step2", async () => {
      someOtherWork(result1);
    });
  },
);
```

```javascript parallel
export const POST = serve<string>(
  async (context) => {
    const input = context.requestPayload;
    const promise1 = context.run("step1", async () => {
      return someWork(input);
    });

    const promise2 = context.run("step2", async () => {
      return someOtherWork(input);
    });

    await Promise.all([promise1, promise2]);
  },
);
```
</CodeGroup>

If `context.run` throws an exception, the SDK automatically handles it by retrying the `context.run` operation three times with exponentially increasing delays, as [explained here](/qstash/features/retry). This behavior will be configurable in [upcoming releases](/qstash/workflows/roadmap).

### `context.sleep` method

`context.sleep` postpones the execution of the code for a specified duration (in seconds). The code will exit and not consume any function time. After the specified duration, the endpoint will be called again to resume execution.

The sleep duration can be as long as a week or a year, depending on your [QStash plan (Max Delay)](https://upstash.com/pricing/qstash).

<Warning>
Always use `sleep` with `await` in front, or it will not block the execution as expected.
</Warning>

```javascript
export const POST = serve<string>(
  async (context) => {
    const input = context.requestPayload;

    const user = await context.run("signin", async () => {
      const user = saveUserToDB(input);
      return user;
    });

    await context.sleep("waitForWelcomeEmail", daysToSeconds(3));

    await context.run("sendWelcomeEmail", async () => {
      return sendEmail(user.name, user.email);
    });
  },
);
```

### `context.sleepUntil` Method

`context.sleepUntil` postpones the execution of the code until a specified timestamp. The code will exit and not consume any function time. On the given timestamp, the endpoint will be called again to resume execution.

The sleepUntil duration can be as long as a week or a year, depending on your [QStash plan (Max Delay)](https://upstash.com/pricing/qstash).

<Warning>
Always use `sleepUntil` with `await` in front, or it will not block the execution as expected. 
</Warning>

```javascript
export const POST = serve<string>(
  async (context) => {
    const input = context.requestPayload;

    const user = await context.run("signin", async () => {
      const user = saveUserToDB(input);
      return user;
    });

    await context.sleepUntil("waitForWelcomeEmail", nextWeek());

    await context.run("sendWelcomeEmail", async () => {
      return sendEmail(user.name, user.email);
    });
  },
);
```

### `context.call` Method

`context.call` is used to call an HTTP endpoint as a step. While this can be done inside `context.run`, the key difference is that `context.call` does not wait for the called endpoint to return. This allows you to bypass the time limitations of the platform. When the response is ready, the function will continue as if resuming from the return of the `context.call`.

The endpoint can take up to 15 minutes or 2 hours to respond, depending on your [QStash plan (Max HTTP Connection Timeout)](https://upstash.com/pricing/qstash).

```javascript
export const POST = serve<{ question: string, email: string }>(
  async context => {
    const request = context.requestPayload
    const llmResponse = await context.call(
      "call open ai",
      "https://api.openai.com/v1/chat/completions",
      "POST", 
      {
        model: "gpt-4o",
        messages: [
          { role: "system", content: "You are a helpful assistant." },
          { role: "user", content: request.question }
        ]
      },
      {
        authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
      }
    );

     await context.run("sendEmail", async () => {
      return sendEmail(request.email, llmResponse)
    })
  }
)
```

If `context.call` returns a non-success status code (anything other than 2xx), the SDK automatically retries the call three times with exponentially increasing delays, as [explained here](/qstash/features/retry). This behavior will be configurable in [upcoming releases](/qstash/workflows/roadmap).
